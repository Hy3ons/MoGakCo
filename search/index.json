[{"content":"하계 모각코 02 - 목표 이번 모각코 시간에는, udemy spring 강의의 143 번째 강의부터 150분간 강의를 듣고 공부한 내용과 궁금한 부분 따로 알아분 부분들에 대해서 추가적으로 적어볼 예정입니다.\n대체로 강의 내용은, JPA와 Hibernates 를 다루며, REST API를 만들어 보는 영상이며, 추가로 에러 핸들링과, Spring Security등이 있습니다.\n오늘의 목표 강의 목록 모든 리소스에 대한 예외 처리 구현 DELETE 메소드로 사용자 리소스 삭제 REST API에서 유효성 검증 적용 고급 REST API 기능 개요 파악 Open API 사양 및 Swagger 이해 springdoc-openapi 의존성 추가 및 Swagger 문서 자동 생성 구성 콘텐츠 협상 및 XML 지원 구현 REST API의 국제화(i18n) 적용 REST API 버전 관리 (URI, 요청 매개변수, 헤더, 콘텐츠 협상 방식) 짧은 시간 동안 여러 주제를 다루겠지만, 각 단계별로 핵심만 정리해보는 것이 오늘의 목표입니다.\n하계 모각코 02 - 결과 전역 예외 처리 - @ControllerAdvice + ExceptionHandler 1 2 3 4 5 6 7 8 9 @ControllerAdvice public class CustomizedResponseEntityExceptionHandler extends ResponseEntityExceptionHandler { @ExceptionHandler(Exception.class) public final ResponseEntity\u0026lt;Object\u0026gt; handleAllException(Exception ex, WebRequest request) { ErrorDetails errorDetails = new ErrorDetails(LocalDateTime.now(), ex.getMessage(), request.getDescription(false)); return new ResponseEntity\u0026lt;\u0026gt;(errorDetails, HttpStatus.INTERNAL_SERVER_ERROR); } } 예외에 관한 내용이다. 이런식으로, @ExceptionHandler와 관련된 @ControllerAdvice 애너테이션으로 Bean을 등록해주고, 상속받은 메서드와 새롭게 정의된 내부 ExceptionHandler를 통해 에러를 다룰 수 있다.\nResponseEntityExceptionHandler를 상속하는 이유는 다음과 같다.\n@ControllerAdvice는 Spring의 전역 예외 처리자이다. 그래서 상속하지 않으면, @Valid, @RequestBody 등의 에러는 InternalServerError로 처리될 수 있다.\nResponseEntityExceptionHandler에 기본적으로 정의되어 있는 메서드들,\nhandleMethodArgumentNotValid나, handleHttpMessageNotReadable 같은 기본적인 오류 처리 로직을 사용할 수 있다.\n우리가 전역 예외 처리자를 새롭게 등록하면, Spring에서는 기본 예외 처리 로직을 지원 중단하기 때문에, 기존 것을 모두 사용하기 위해서는 상속을 받아야 한다.\n저런식으로 리턴을 하면, errorDetails라는 객체가 JSON, stringify 되어 response로 날아간다.\n예외를 쉽게 client에 전역적으로 처리할 수 있게 되는 셈이다.\n유효성 검증 - @Valid + Jakarta Validation 각 파라미터의 유효성 검증은 파라미터 앞에 @Valid 애너테이션을 다는 것으로 배웠었다.\n하지만 이것은 @ResponseBody로 객체 타입이 파라미터로 주어져도 @Valid로 유효성 검증을 수행할 수 있다.\n1 2 3 4 5 @PostMapping(\u0026#34;/users\u0026#34;) public ResponseEntity\u0026lt;User\u0026gt; createUser(@Valid @RequestBody User user) { User savedUser = userRepository.save(user); return ResponseEntity.ok(savedUser); } 이런식으로 @Valid를 넣어주고,\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 @Entity(name = \u0026#34;users\u0026#34;) public class User { @Id @GeneratedValue(strategy = GenerationType.AUTO) private int id; @Size(min = 2, message = \u0026#34;이름은 적어도 2글자 이상 넣어주세요.\u0026#34;) private String name; @Past(message = \u0026#34;미래는 생일로 지정 할 수 없습니다.\u0026#34;) private LocalDate birthdate; private Integer solver; } 검증할 각 객체의 멤버에 Jakarta 형식의 검증 애너테이션을 넣으면 된다.\n전역적으로 @Valid 오류는 그 원인을 클라이언트에게 기본적으로 전달하지 않는다.\n1 2 3 4 5 6 7 8 @Override protected ResponseEntity\u0026lt;Object\u0026gt; handleMethodArgumentNotValid(MethodArgumentNotValidException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request) { ErrorDetails er = new ErrorDetails(LocalDateTime.now(), ex.getMessage(), request.getDescription(false)); return new ResponseEntity\u0026amp;lt;\u0026amp;gt;(er, HttpStatus.BAD_REQUEST); } 이런식으로 ResponseEntityExceptionHandler의 메서드를 오버라이딩하여 에러 처리 시 client 에게 돌아가는 내용을 수정할 수 있다.\n1 2 3 4 5 6 7 8 9 10 11 12 @Override protected ResponseEntity\u0026lt;Object\u0026gt; handleMethodArgumentNotValid(MethodArgumentNotValidException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request) { ErrorDetails er = new ErrorDetails(LocalDateTime.now(), ex.getFieldErrors().stream() .map(fieldError -\u0026gt; fieldError.getDefaultMessage()) .collect(Collectors.joining(\u0026#34;, \u0026#34;)), request.getDescription(false)); return new ResponseEntity\u0026lt;\u0026gt;(er, HttpStatus.BAD_REQUEST); } Swagger를 이용한 문서 자동화 Swagger 적용은 매우 간단했다. 의존성 추가만으로 적용되며, input schema를 대충 지정해도 알아서 잘 매핑해준다.\n1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.fasterxml.jackson.dataformat\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jackson-dataformat-xml\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 이러한 종속성 추가를 통해, client의 header에 \u0026ldquo;accept\u0026rdquo; : \u0026ldquo;application/xml\u0026quot;을 넣으면\n자동으로 반환하는 콘텐츠의 반환 형식을 제공할 수 있다.\nSwagger와 XML은 문서 충돌을 일으킬 수 있으니 주의하자.\n국제화 (i18n) 지원 resources 폴더에 messages_{tag}.properties 파일들을 만들어 다국어 처리를 할 수 있다.\n1 2 3 4 5 @GetMapping(path=\u0026#34;/hello-world-i18n\u0026#34;) public String hel() { Locale locale = LocaleContextHolder.getLocale(); return messageSource.getMessage(\u0026#34;good.morrning.message\u0026#34;, null, \u0026#34;default\u0026#34;, locale); } LocaleContextHolder.getLocale()을 통해 현재 요청의 locale을 추출하고,\n그에 맞는 메시지를 리턴해준다.\nAPI 버전 전략 URI 버전 방식 (Twitter 스타일) 1 2 GET /v1/users GET /v2/users 요청 파라미터 방식 (Amazon 스타일) 1 2 GET /users?version=1 GET /users?version=2 Header 방식 (Microsoft 스타일) 1 2 Header: API_VERSION=1 Header: API_VERSION=2 API의 request/response DTO에 변화가 생기더라도 기존 consumer들을 보호할 수 있는 좋은 전략이다.\n","date":"2025-07-27T21:20:00+09:00","image":"https://hy3ons.github.io/MoGakCo/p/2025-01-mogakco-2/cover_hu_ae58cfd9ceaaf6cf.png","permalink":"https://hy3ons.github.io/MoGakCo/p/2025-01-mogakco-2/","title":"하계 모각코 02"},{"content":"하계 모각코 01 - 목표 이번 모각코 시간에는 유데미 강의를 들으며, Spring Boot와 JPA, Hibernate, Spring JDBC 등 다양한 주제를 공부할 예정입니다.\n특히, 프로덕션 환경 배포 준비, Actuator, Spring MVC, JPA와 Hibernate, H2 콘솔, Spring JDBC 등 여러 내용을 주제로 하는 영상을 시청 할 예정입니다.\n저는 모각코 시간에만 공부하는 것이 아니다 보니, 그때그때 관심사나 공부의 진도, 필요에 따라 주제가 달라질 수 있습니다.\n이번 시간에는 아래와 같은 강의들을 목표로 삼고, 각 단계별로 짧게라도 정리해보려 합니다.\n오늘의 목표 강의 목록 Spring Boot로 프로덕션 환경 배포 준비하기 (Embedded Server, Actuator) Spring Boot, Spring, Spring MVC 이해하기 Spring Boot 시작하기 - 복습 JPA와 Hibernate 시작하기 및 새 프로젝트 설정 H2 콘솔 실행 및 과정 테이블 생성 Spring JDBC 시작 및 데이터 삽입/삭제/쿼리 실습 JPA 실습 짧은 시간 동안 여러 주제를 다루겠지만, 각 단계별로 핵심만 정리해보는 것이 오늘의 목표입니다.\n하계 모각코 01 - 결과 1. Maven을 이용한 빌드와 실행 Maven 명령어 활용법 mvn clean : 기존 빌드 산출물(클래스, jar 등)을 삭제 mvn install : 컴파일 → 테스트 → 패키징 → 로컬 Maven 저장소에 배포 Spring Boot 실행 빌드된 .jar 파일을 커맨드라인에서 실행 가능 1 java -jar target/myapp.jar 2. Spring Boot Actuator를 통한 모니터링 Spring Boot Actuator는 애플리케이션 상태, 메트릭, 헬스 체크 등 다양한 모니터링 기능을 제공합니다. 주요 엔드포인트 예시 /actuator/health : 서비스 상태 확인 /actuator/metrics : 메트릭 정보 제공 보안 설정 필수 (민감 정보 노출 방지) actuator 엔드포인트 노출 설정 (기본은 제한적임) 1 management.endpoints.web.exposure.include=health,metrics,info 3. DB 연동 및 SQL 활용 메모리 기반 DB 사용 H2 같은 인메모리 DB로 빠른 개발과 테스트 가능, 강의영상에는 H2 SQL을 사용해서, 실습하였다. JDBC vs Spring JDBC vs JPA 비교 구분 특징 JDBC 순수 자바 DB 연동, SQL 직접 작성, 번거로움 Spring JDBC JDBC API 래핑, 예외 변환 및 편의 메서드 제공, SQL 직접 작성해야한다ㅓ JPA 객체와 테이블 매핑, ORM 제공, 복잡한 DB 작업 간결화 4. Spring Data JPA 기본 사용법 JpaRepository 인터페이스 상속만으로 CRUD 자동 구현해준다.\nSpring Boot가 런타임 시점에 인터페이스 구현체(프록시)를 생성하여 Bean으로 등록\n메서드 이름만으로 쿼리 자동 생성 가능\n예) findByName, findByCreatedAtAfter 등\n직접 쿼리를 작성하고 싶으면 @Query 어노테이션을 사용할 수 있다.\n1 2 3 4 5 6 7 8 9 10 public interface CourseRepository extends JpaRepository\u0026lt;Course, Long\u0026gt; { // JPQL 직접 작성 @Query(\u0026#34;SELECT c FROM Course c WHERE c.name = :name\u0026#34;) List\u0026lt;Course\u0026gt; findByNameCustom(@Param(\u0026#34;name\u0026#34;) String name); // 네이티브 쿼리 사용 (nativeQuery=true) @Query(value = \u0026#34;SELECT * FROM course WHERE created_at \u0026gt; :date\u0026#34;, nativeQuery = true) List\u0026lt;Course\u0026gt; findRecentCoursesNative(@Param(\u0026#34;date\u0026#34;) LocalDate date); } 5. 복잡한 로직 확장 방법 5.1 Custom Repository 구현 복잡한 쿼리나 동적 쿼리 작성 시 별도의 커스텀 인터페이스와 구현체 작성 필요 예시 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public interface CourseCustomRepository { List\u0026lt;Course\u0026gt; findRecentCourses(); } @Repository public class CourseCustomRepositoryImpl implements CourseCustomRepository { @PersistenceContext private EntityManager em; public List\u0026lt;Course\u0026gt; findRecentCourses() { // JPQL 직접 작성 return em.createQuery(\u0026#34;SELECT c FROM Course c WHERE c.createdAt \u0026gt; :date\u0026#34;, Course.class) .setParameter(\u0026#34;date\u0026#34;, LocalDate.now().minusDays(7)) .getResultList(); } } public interface CourseRepository extends JpaRepository\u0026lt;Course, Long\u0026gt;, CourseCustomRepository { } 6. EntityManager와 @PersistenceContext EntityManager는 JPA의 핵심으로,\n영속성 컨텍스트(1차 캐시)와 트랜잭션 상태를 관리하는\n상태가 있는 객체입니다.\n@PersistenceContext를 사용해 주입하며,\n내부적으로는 트랜잭션마다 별도의 EntityManager 인스턴스를\n프록시를 통해 트랜잭션 컨텍스트에 맞게 연결해줍니다.\n직접 싱글톤 Bean으로 쓰면 상태 공유로 인한\n동시성 문제와 상태 꼬임이 발생할 수 있으니 주의해야 합니다.\n따라서, @AutoWired를 사용하면 안 됩니다.\n7. Hibernate와 JPA JPA는 Java ORM의 표준 인터페이스(스펙)입니다.\nHibernate는 JPA 스펙을 구현한\n가장 널리 쓰이는 ORM 구현체(라이브러리)입니다.\nSpring Boot는 기본적으로 Hibernate를\nJPA 구현체로 사용하여 ORM 기능을 제공합니다.\n강의 외 추가적인 공부 : 다중 데이터소스 관리 하나의 Spring Boot 애플리케이션에서 여러 개의 데이터베이스를 사용하고,\n각 데이터베이스에 연결된 JPA Repository를 분리하고 싶을 때,\n멀티 데이터소스 설정이 필요합니다.\n1. 멀티 데이터소스 설정 개요 각 데이터베이스별로 DataSource 빈을 생성 각각에 맞는 EntityManagerFactory 빈 생성 TransactionManager도 데이터소스별로 분리 @EnableJpaRepositories를 이용해 Repository 패키지별로 연결 분리 2. 각각의 DB 설정 (PrimaryDataSourceConfig.java) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 @Configuration // 이 클래스는 Spring 설정 클래스임을 나타냄 @EnableTransactionManagement // @Transactional 애노테이션 기반의 트랜잭션 기능을 활성화함 @EnableJpaRepositories( basePackages = \u0026#34;com.example.primaryRepo\u0026#34;, // 이 경로 하위에 있는 Repository 인터페이스들이 이 데이터소스를 사용하도록 설정 entityManagerFactoryRef = \u0026#34;primaryEntityManagerFactory\u0026#34;, // 사용할 EntityManagerFactory Bean 이름 transactionManagerRef = \u0026#34;primaryTransactionManager\u0026#34; // 사용할 트랜잭션 매니저 Bean 이름 ) public class PrimaryDataSourceConfig { /** * primaryDataSource: 첫 번째 데이터베이스와 연결할 DataSource를 생성. * application.properties 파일에서 \u0026#39;spring.datasource.primary\u0026#39; 접두어로 시작하는 설정을 읽어들임. * 예: spring.datasource.primary.url, username, password, driver-class-name 등 */ @Bean @Primary // 여러 DataSource 중 기본(우선순위)으로 사용됨 @ConfigurationProperties(prefix = \u0026#34;spring.datasource.primary\u0026#34;) public DataSource primaryDataSource() { return DataSourceBuilder.create().build(); } /** * primaryEntityManagerFactory: JPA에서 사용할 EntityManagerFactory를 생성. * - 이 팩토리는 해당 DataSource로 DB 연결을 수행하며, * - 지정한 Entity 클래스들이 어떤 DB와 연동될지 결정한다. * - \u0026#39;packages()\u0026#39;에 명시된 경로 하위의 Entity 클래스들을 스캔한다. * - persistenceUnit 이름은 구분용이므로 임의로 설정 가능함. */ @Bean @Primary public LocalContainerEntityManagerFactoryBean primaryEntityManagerFactory( EntityManagerFactoryBuilder builder) { return builder .dataSource(primaryDataSource()) // 위에서 만든 DataSource 사용 .packages(\u0026#34;com.example.primaryentity\u0026#34;) // JPA Entity 클래스가 위치한 패키지 .persistenceUnit(\u0026#34;primary\u0026#34;) // persistence-unit 이름 (JPA 설정의 논리적 이름) .build(); } /** * primaryTransactionManager: 해당 EntityManagerFactory를 사용하는 트랜잭션 관리자 생성. * - @Transactional 동작 시, 이 트랜잭션 매니저가 사용됨. * - 하나의 데이터소스에 하나의 트랜잭션 매니저가 대응되어야 함. */ @Bean @Primary public PlatformTransactionManager primaryTransactionManager( @Qualifier(\u0026#34;primaryEntityManagerFactory\u0026#34;) EntityManagerFactory emf) { return new JpaTransactionManager(emf); // 해당 EntityManagerFactory에 대한 트랜잭션 관리 } } 궁금해서 따로 알아본 내용이며, 실제로 데이터 소스를 여러군대에서 가져와, 활용하는 방식은 보안상에 좋을 순 있지만, 복잡성을 유발하는 것 같아서, 알아만 두자.\n","date":"2025-07-14T20:45:00+09:00","image":"https://hy3ons.github.io/MoGakCo/p/2025-01-mogakco-1/cover_hu_ae58cfd9ceaaf6cf.png","permalink":"https://hy3ons.github.io/MoGakCo/p/2025-01-mogakco-1/","title":"하계 모각코 01"},{"content":"안녕하세요, 황현석입니다! 🍥 반갑습니다! 이곳은 모각코를 진행하며 제 학습 과정과 성장을 기록하는 개인 블로그입니다.\n왜 이 블로그를 만들었을까요? 기존에 운영하는 블로그 하나는 알고리즘 중심의 문제풀이 블로그 하나만 운영하고 있었습니다.\n하지만 모각코에서는 단순한 알고리즘 풀이를 넘어, 다양한 기술 스택을 배우고, 개발 프로젝트를 진행하며, 팀원들과 협업하는 등 훨씬 더 폭넓은 활동이 이루어집니다.\n그런 활동들을 기존 블로그에 혼합해 기록하기보다는, 각각의 모각코 활동에 집중된 별도의 공간이 필요하다고 판단했습니다. 그래서 이 블로그를 새롭게 개설하게 되었고, 앞으로 이곳을 통해 매일의 학습 기록, 프로젝트 개발 일지, 그리고 깨달은 점들을 정리하며 꾸준히 성장해 나가고자 합니다.\n저는 어떤 것에 관심이 있을까요? 저는 실제 사용자에게 편의를 제공하는 웹사이트나 서비스를 직접 만들어내는 것에 관심이 있습니다. 웹페이지를 직접 구현하고, 백엔드에서 데이터를 처리하거나 웹훅/이메일 등 다양한 채널로 정보를 전달하는 시스템을 구축하는 과정에 흥미가 있습니다.\n또한, 머신러닝과 딥러닝에도 깊은 관심을 가지고 있습니다. 현재는 Kaggle 문제를 풀며 실전 감각을 키우는 중이며, 이후에는 논문 기반의 심화 학습을 통해 더 깊은 수준의 연구와 개발로 나아가고자 합니다.\n이미 개인적으로는 딥러닝의 핵심인 역전파 알고리즘을 numpy만으로 직접 구현해 본 경험이 있으며, 커스텀 옵티마이저와 학습 루프도 모듈화하여 제작한 적이 있습니다. 이런 경험을 바탕으로, 단순한 라이브러리 사용을 넘어, 내부 원리에 대한 이해와 구현 능력을 함께 키워가는 것을 지향하고 있습니다.\n","date":"2025-06-21T16:05:00+09:00","image":"https://hy3ons.github.io/MoGakCo/p/hello-mogakco-2025/cover_hu_e95a4276bf860a84.jpg","permalink":"https://hy3ons.github.io/MoGakCo/p/hello-mogakco-2025/","title":"2025 하계 모각코 블로그를 시작하며"}]